#!/bin/env python3

from typing import NamedTuple
import subprocess
from typing import Any, Iterator
import json
import sys
import os
import time


class OutputParams(NamedTuple):
    x: int
    y: int
    scale: float


class Rect(NamedTuple):
    w: int
    h: int
    x: int
    y: int

    @classmethod
    def from_xywh(cls, x, y, w, h) -> "Rect":
        return cls(w, h, x, y)

    def to_bbox(self) -> tuple[int, int, int, int]:
        return (
            self.x,
            self.y,
            self.x + self.w,
            self.y + self.h,
        )

    def relative_to_output(
        self, output: OutputParams | None, window: "Rect | None"
    ) -> "Rect":
        if output is None:
            output = OutputParams(x=0, y=0, scale=1)

        if window is None:
            window = Rect(0, 0, 0, 0)

        return Rect(
            round(self.w / output.scale),
            round(self.h / output.scale),
            round(self.x / output.scale + window.x - output.x),
            round(self.y / output.scale + window.y - output.y),
        )

    def __str__(self) -> str:
        return f"{self.w}x{self.h}+{self.x}+{self.y}"


def get_active_windows_rect() -> tuple[OutputParams | None, Rect | None]:
    def walk(
        node: dict[str, Any],
        curr_output_params: OutputParams | None,
    ) -> Iterator[tuple[OutputParams, Rect]]:
        if node.get("type") == "output":
            curr_output_params = OutputParams(
                x=node["rect"]["x"],
                y=node["rect"]["y"],
                scale=node.get("scale", 0),
            )

        sub_nodes = node.get("floating_nodes")
        if sub_nodes:
            for sub_node in sub_nodes:
                yield from walk(sub_node, curr_output_params)

        sub_nodes = node.get("nodes")
        if sub_nodes:
            for sub_node in sub_nodes:
                yield from walk(sub_node, curr_output_params)

        elif node.get("pid") and node.get("focused"):
            r = node["rect"]
            yield (curr_output_params, Rect(r["width"], r["height"], r["x"], r["y"]))

    process = subprocess.run(
        ["swaymsg", "-t", "get_tree"],
        capture_output=True,
        check=True,
    )
    tree = json.loads(process.stdout.decode())
    return next(walk(tree, None), (None, None))


def run():
    import pyscreenshot
    import cv2 as cv
    import numpy as np

    output_params, active_win_rect = get_active_windows_rect()
    if active_win_rect is None:
        print("No active window found. Quitting.", file=sys.stderr)
        return

    img = cv.cvtColor(
        np.array(pyscreenshot.grab(active_win_rect.to_bbox())), cv.COLOR_BGR2GRAY
    )

    edges = cv.Canny(img, 70, 220)
    kernel = np.ones(
        (round(4 * output_params.scale), round(4 * output_params.scale)), np.uint8
    )
    dilated_edges = cv.dilate(edges, kernel)
    contours, _ = cv.findContours(dilated_edges, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE)

    rects = [
        rect
        for rect in (
            Rect.from_xywh(*cv.boundingRect(contour)).relative_to_output(
                output_params, active_win_rect
            )
            for contour in contours
        )
        if rect.h < 50 and rect.w < 500 and rect.h > 7 and rect.w > 7
    ]

    process = subprocess.run(
        ["wl-kbptr"],
        input="\n".join(map(str, rects)).encode(),
        check=False,
    )


def get_namedpipe_path() -> str:
    run_dir = os.getenv("XDG_RUNTIME_DIR", "/tmp")
    wayland_display = os.getenv("WAYLAND_DISPLAY", "wayland-0")
    return f"{run_dir}/wl-kbptr-hints-{wayland_display}"


def run_loop(pipe_path):
    try:
        os.mkfifo(pipe_path)
        run()
        while True:
            with open(pipe_path) as pipe:
                while line := pipe.readline():
                    match line.strip():
                        case "run":
                            run()
                        case "quit":
                            return
    finally:
        os.unlink(pipe_path)


def main():
    pipe_path = get_namedpipe_path()
    running = False
    try:
        os.stat(pipe_path)
        running = True
    except:
        pass

    if running:
        print("Already running. Sending 'run' message.", file=sys.stderr)
        with open(pipe_path, "a") as pipe:
            pipe.write("run\n")

    else:
        run_loop(pipe_path)


if __name__ == "__main__":
    main()
